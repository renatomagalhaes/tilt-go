# Carrega a extensão restart_process que permite reiniciar o processo dentro do container
load('ext://restart_process', 'docker_build_with_restart')

# Carrega os serviços definidos no Docker Compose para dependências
docker_compose('./docker-compose.yml')

# Adiciona labels aos serviços do Docker Compose para organização na UI do Tilt
dc_resource('mysql', labels=['database'])
dc_resource('memcached', labels=['cache'])
dc_resource('rabbitmq', labels=['queue'])

# Define quais contextos Kubernetes são permitidos
# Opções disponíveis:
# - 'docker-desktop': Kubernetes integrado ao Docker Desktop (padrão)
# - 'minikube': Ambiente Kubernetes local via Minikube
# - 'microk8s': Kubernetes leve para desenvolvimento local
# - 'kind': Kubernetes em Docker para testes e desenvolvimento
# Para habilitar múltiplos contextos, use: allow_k8s_contexts(['docker-desktop', 'minikube', 'microk8s', 'kind'])
allow_k8s_contexts('docker-desktop')

# Configuração do servidor API
docker_build_with_restart(
    'api-server',                    # Nome da imagem Docker
    '../..',                         # Diretório do código fonte (contexto de build)
    dockerfile='../../api/Dockerfile.dev', # Caminho do Dockerfile
    # Definindo o entrypoint usando o caminho do módulo para o pacote
    entrypoint=["go", "run", "github.com/renatomagalhaes/tilt-go/api"],
    live_update=[
        sync('../../api', '/app/api'), # Sincronizar apenas o diretório api
        sync('../../internal', '/app/internal'), # Sincronizar o diretório internal
        # O comando run agora usa go run com o caminho do módulo para o pacote
        run('go run github.com/renatomagalhaes/tilt-go/api'),
    ]
)

# Carrega os manifests Kubernetes da API
k8s_yaml('./k8s/api-config.yaml')
k8s_yaml('./k8s/api.yaml')
k8s_resource('api-server', port_forwards=8080, labels=['api'])

# Configuração do Worker
docker_build_with_restart(
    'worker-server',                 # Nome da imagem Docker
    '../..',                         # Diretório do código fonte (contexto de build)
    dockerfile='../../worker/Dockerfile.dev',  # Caminho do Dockerfile
    # Definindo o entrypoint usando o caminho do módulo para o pacote
    entrypoint=["go", "run", "github.com/renatomagalhaes/tilt-go/worker"],
    live_update=[
        sync('../../worker', '/app/worker'), # Sincronizar apenas o diretório worker
        sync('../../internal', '/app/internal'), # Sincronizar o diretório internal
        # O comando run agora usa go run com o caminho do módulo para o pacote
        run('go run github.com/renatomagalhaes/tilt-go/worker'),
    ]
)

# Carrega os manifests Kubernetes do Worker
k8s_yaml('./k8s/worker-config.yaml')
k8s_yaml('./k8s/worker.yaml')
k8s_resource('worker-server', port_forwards=8081, labels=['worker'])

# Cria recursos Tilt para os ConfigMaps e aplica labels
k8s_resource(
    objects=['api-config:configmap'],
    new_name='api-config',
    labels=['api']
)

k8s_resource(
    objects=['worker-config:configmap'],
    new_name='worker-config',
    labels=['worker']
) 